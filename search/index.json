[{"content":"大苏打实打实的撒大大大大苏打\n自定义域名真的折磨\n真的难搞，这个感觉有延迟啊\n","date":"2025-07-16T00:00:00Z","permalink":"https://keepulser.top/p/hugo/","title":"githubpages+ssh+hugo做个人博客"},{"content":"[TOC]\n常用数据结构API 1.列表 int 转 list\n1 2 num = 123 nums = list(map(int, str(num))) list(int) 转 int\n1 2 3 4 5 nums = [1, 2, 3] num = int(\u0026#39;\u0026#39;.join(map(str, nums))) def lst_int(nums): return int(\u0026#39;\u0026#39;.join(map(str, nums))) 列表特性\n比较大小的时候，不管长度如何，依次比较到第一个元素不相等的位置\n比如[1, 2, 3] \u0026lt; [2, 3] 因为在比较1 \u0026lt; 2的时候就终止。\n嵌套列表推导：展平二维数组\n1 nums = [e for row in matrix for e in row] 2.Deque 1 2 3 4 5 6 7 8 9 10 from collections import deque list1 = [0, 1, 2, 3] q=deque(list1) q.append(4) # 向右侧加\tq.appendleft(-1) #向左侧加 q.extend(可迭代元素) #向右侧添加可迭代元素 q.extendleft(可迭代元素) q=q.pop() #移除最右端并返回元素值 l=q.popleft() #移除最左端 q.count(1) #统计元素个数 1 1 2 3 4 # 返回string指定范围中str首次出现的位置 string.index(str, beg=0, end=len(string)) string.index(\u0026#34; \u0026#34;) list(map(s.index,s))\t#返回字符索引数组，如\u0026#34;abcba\u0026#34;-\u0026gt;[0,1,2,1,0] 3.字典 1 2 3 4 5 6 d.pop(key)\t#返回key对应的value值，并在字典中删除这个键值对 d.get(key,default_value)\t#获取key对应的值，如果不存在返回default_value d.keys() #键构成的可迭代对象 d.values()\t#值构成的可迭代对象 d.items()\t#键值对构成的可迭代对象 d = defaultdict(list)\t# 指定了具有默认值空列表的字典 字典推导器 字母表对应下标\n1 dic = {chr(i) : i - ord(\u0026#39;a\u0026#39;) + 1 for i in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1)} 也可以使用zip初始化dic\n2606. 找到最大开销的子字符串 - 力扣（LeetCode）\n1 2 3 dic = dict(zip(chars, vals))\tfor x in s: y = dic.get(x, ord(x) - ord(\u0026#39;a\u0026#39;) + 1) 4.map映射函数 用法:\n1 map(function, iterable, ...) 1 2 3 4 5 6 7 8 9 10 11 12 def square(x) : # 计算平方数 return x ** 2 map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 # [1, 4, 9, 16, 25] map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 # [1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加 map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) # [3, 7, 11, 15, 19] 5. 自定义Set规则 1 2 3 4 5 class MySet(set): def add(self, element): sorted_element = tuple(sorted(element)) if not any(sorted_element == e for e in self): super().add(sorted_element) 1 2 3 4 s = MySet() s.add((2, 1, 1)) s.add((1, 2, 1)) print(s) # 输出：{(1, 1, 2)} 6. 基本输入输出 快读快写\n1 2 3 4 import sys sys.setrecursionlimit(1000000) input=lambda:sys.stdin.readline().strip() write=lambda x:sys.stdout.write(str(x)+\u0026#39;\\n\u0026#39;) 读到文件结尾\n1 2 3 4 import sys for line in sys.stdin: line = line.strip() 3701. 非素数个数 - AcWing题库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys n = 10 ** 7 primes = [] is_prime = [1] * (n + 1) is_prime[0] = is_prime[1] = 0 for i in range(2, n + 1): if is_prime[i]: primes.append(i) for p in primes: if i * p \u0026gt; n: break is_prime[i * p] = 0 if i % p == 0: break a = [0] * (n + 1) for i in range(2, n + 1): a[i] = a[i - 1] + (1 if not is_prime[i] else 0) for line in sys.stdin: input = line.strip() l, r = map(int, input.split()) print(a[r] - a[l - 1]) 7.优先队列 / 堆 1 2 3 4 5 6 from heapq import heapify, heappop, heappush heapify(nums) score = heappop(nums) heappush(nums, val) # 注意： # python中堆默认且只能是小顶堆 1 2 3 nums = [] heapq.heappush(nums, val)\t#插入 heapq.heappop(nums)\t#弹出顶部 8. 有序列表 / 有序集合 SortedList\n1 from sortedcontainers import SortedList SortedList 相当于 multiset\n添加元素：$O(\\log ~n)$；s.add(val)\n添加一组可迭代元素：$O(k \\log n)$；s.upadte(*iterable*)\n查找元素：$O(\\log n)$；s.count(val)，返回元素的个数\n删除元素：$O(\\log n)$； $s.remove(val)$\n删除指定下标元素：$s.pop(index =- 1)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class SortedList: def __init__(self, iterable=[], _load=200): \u0026#34;\u0026#34;\u0026#34;Initialize sorted list instance.\u0026#34;\u0026#34;\u0026#34; values = sorted(iterable) self._len = _len = len(values) self._load = _load self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)] self._list_lens = [len(_list) for _list in _lists] self._mins = [_list[0] for _list in _lists] self._fen_tree = [] self._rebuild = True def _fen_build(self): \u0026#34;\u0026#34;\u0026#34;Build a fenwick tree instance.\u0026#34;\u0026#34;\u0026#34; self._fen_tree[:] = self._list_lens _fen_tree = self._fen_tree for i in range(len(_fen_tree)): if i | i + 1 \u0026lt; len(_fen_tree): _fen_tree[i | i + 1] += _fen_tree[i] self._rebuild = False def _fen_update(self, index, value): \u0026#34;\u0026#34;\u0026#34;Update `fen_tree[index] += value`.\u0026#34;\u0026#34;\u0026#34; if not self._rebuild: _fen_tree = self._fen_tree while index \u0026lt; len(_fen_tree): _fen_tree[index] += value index |= index + 1 def _fen_query(self, end): \u0026#34;\u0026#34;\u0026#34;Return `sum(_fen_tree[:end])`.\u0026#34;\u0026#34;\u0026#34; if self._rebuild: self._fen_build() _fen_tree = self._fen_tree x = 0 while end: x += _fen_tree[end - 1] end \u0026amp;= end - 1 return x def _fen_findkth(self, k): \u0026#34;\u0026#34;\u0026#34;Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) \u0026lt;= k`, `k - sum(_fen_tree[:idx])`).\u0026#34;\u0026#34;\u0026#34; _list_lens = self._list_lens if k \u0026lt; _list_lens[0]: return 0, k if k \u0026gt;= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len if self._rebuild: self._fen_build() _fen_tree = self._fen_tree idx = -1 for d in reversed(range(len(_fen_tree).bit_length())): right_idx = idx + (1 \u0026lt;\u0026lt; d) if right_idx \u0026lt; len(_fen_tree) and k \u0026gt;= _fen_tree[right_idx]: idx = right_idx k -= _fen_tree[idx] return idx + 1, k def _delete(self, pos, idx): \u0026#34;\u0026#34;\u0026#34;Delete value at the given `(pos, idx)`.\u0026#34;\u0026#34;\u0026#34; _lists = self._lists _mins = self._mins _list_lens = self._list_lens self._len -= 1 self._fen_update(pos, -1) del _lists[pos][idx] _list_lens[pos] -= 1 if _list_lens[pos]: _mins[pos] = _lists[pos][0] else: del _lists[pos] del _list_lens[pos] del _mins[pos] self._rebuild = True def _loc_left(self, value): \u0026#34;\u0026#34;\u0026#34;Return an index pair that corresponds to the first position of `value` in the sorted list.\u0026#34;\u0026#34;\u0026#34; if not self._len: return 0, 0 _lists = self._lists _mins = self._mins lo, pos = -1, len(_lists) - 1 while lo + 1 \u0026lt; pos: mi = (lo + pos) \u0026gt;\u0026gt; 1 if value \u0026lt;= _mins[mi]: pos = mi else: lo = mi if pos and value \u0026lt;= _lists[pos - 1][-1]: pos -= 1 _list = _lists[pos] lo, idx = -1, len(_list) while lo + 1 \u0026lt; idx: mi = (lo + idx) \u0026gt;\u0026gt; 1 if value \u0026lt;= _list[mi]: idx = mi else: lo = mi return pos, idx def _loc_right(self, value): \u0026#34;\u0026#34;\u0026#34;Return an index pair that corresponds to the last position of `value` in the sorted list.\u0026#34;\u0026#34;\u0026#34; if not self._len: return 0, 0 _lists = self._lists _mins = self._mins pos, hi = 0, len(_lists) while pos + 1 \u0026lt; hi: mi = (pos + hi) \u0026gt;\u0026gt; 1 if value \u0026lt; _mins[mi]: hi = mi else: pos = mi _list = _lists[pos] lo, idx = -1, len(_list) while lo + 1 \u0026lt; idx: mi = (lo + idx) \u0026gt;\u0026gt; 1 if value \u0026lt; _list[mi]: idx = mi else: lo = mi return pos, idx def add(self, value): \u0026#34;\u0026#34;\u0026#34;Add `value` to sorted list.\u0026#34;\u0026#34;\u0026#34; _load = self._load _lists = self._lists _mins = self._mins _list_lens = self._list_lens self._len += 1 if _lists: pos, idx = self._loc_right(value) self._fen_update(pos, 1) _list = _lists[pos] _list.insert(idx, value) _list_lens[pos] += 1 _mins[pos] = _list[0] if _load + _load \u0026lt; len(_list): _lists.insert(pos + 1, _list[_load:]) _list_lens.insert(pos + 1, len(_list) - _load) _mins.insert(pos + 1, _list[_load]) _list_lens[pos] = _load del _list[_load:] self._rebuild = True else: _lists.append([value]) _mins.append(value) _list_lens.append(1) self._rebuild = True def discard(self, value): \u0026#34;\u0026#34;\u0026#34;Remove `value` from sorted list if it is a member.\u0026#34;\u0026#34;\u0026#34; _lists = self._lists if _lists: pos, idx = self._loc_right(value) if idx and _lists[pos][idx - 1] == value: self._delete(pos, idx - 1) def remove(self, value): \u0026#34;\u0026#34;\u0026#34;Remove `value` from sorted list; `value` must be a member.\u0026#34;\u0026#34;\u0026#34; _len = self._len self.discard(value) if _len == self._len: raise ValueError(\u0026#39;{0!r} not in list\u0026#39;.format(value)) def pop(self, index=-1): \u0026#34;\u0026#34;\u0026#34;Remove and return value at `index` in sorted list.\u0026#34;\u0026#34;\u0026#34; pos, idx = self._fen_findkth(self._len + index if index \u0026lt; 0 else index) value = self._lists[pos][idx] self._delete(pos, idx) return value def bisect_left(self, value): \u0026#34;\u0026#34;\u0026#34;Return the first index to insert `value` in the sorted list.\u0026#34;\u0026#34;\u0026#34; pos, idx = self._loc_left(value) return self._fen_query(pos) + idx def bisect_right(self, value): \u0026#34;\u0026#34;\u0026#34;Return the last index to insert `value` in the sorted list.\u0026#34;\u0026#34;\u0026#34; pos, idx = self._loc_right(value) return self._fen_query(pos) + idx def count(self, value): \u0026#34;\u0026#34;\u0026#34;Return number of occurrences of `value` in the sorted list.\u0026#34;\u0026#34;\u0026#34; return self.bisect_right(value) - self.bisect_left(value) def __len__(self): \u0026#34;\u0026#34;\u0026#34;Return the size of the sorted list.\u0026#34;\u0026#34;\u0026#34; return self._len def __getitem__(self, index): \u0026#34;\u0026#34;\u0026#34;Lookup value at `index` in sorted list.\u0026#34;\u0026#34;\u0026#34; pos, idx = self._fen_findkth(self._len + index if index \u0026lt; 0 else index) return self._lists[pos][idx] def __delitem__(self, index): \u0026#34;\u0026#34;\u0026#34;Remove value at `index` from sorted list.\u0026#34;\u0026#34;\u0026#34; pos, idx = self._fen_findkth(self._len + index if index \u0026lt; 0 else index) self._delete(pos, idx) def __contains__(self, value): \u0026#34;\u0026#34;\u0026#34;Return true if `value` is an element of the sorted list.\u0026#34;\u0026#34;\u0026#34; _lists = self._lists if _lists: pos, idx = self._loc_left(value) return idx \u0026lt; len(_lists[pos]) and _lists[pos][idx] == value return False def __iter__(self): \u0026#34;\u0026#34;\u0026#34;Return an iterator over the sorted list.\u0026#34;\u0026#34;\u0026#34; return (value for _list in self._lists for value in _list) def __reversed__(self): \u0026#34;\u0026#34;\u0026#34;Return a reverse iterator over the sorted list.\u0026#34;\u0026#34;\u0026#34; return (value for _list in reversed(self._lists) for value in reversed(_list)) def __repr__(self): \u0026#34;\u0026#34;\u0026#34;Return string representation of sorted list.\u0026#34;\u0026#34;\u0026#34; return \u0026#39;SortedList({0})\u0026#39;.format(list(self)) 字符串 KMP / 模式匹配 暴力匹配所有起始位置\n时间复杂度：$O(mn)$\n1 2 3 4 5 6 for i in range(len_s - len_p + 1): ii, j = i, 0 while j \u0026lt; len_p: if s[ii] == p[j]: ii, j = ii + 1, j + 1 else: break if j == len_p: res.append(i) 前缀函数 / next数组\n时间复杂度：$O(n)$，在线算法\n对于一个长度为 $n$ 的字符串，其前缀函数是一个长度为 $n$ 的数组 $\\pi$，其中 $\\pi(i)$ 定义：子串 $s[0] \\sim s[i]$ 中存在的、相等的最长真前缀和真后缀的长度。如果不存在则为0。规定：$\\pi[0]=0$，因为其不存在真前后缀。\n例如：\u0026lsquo;aabaaab\u0026rsquo; 的 $\\pi$ 数组为 [0, 1, 0, 1, 2, 2, 3]\n求解前缀函数：\n相邻的前缀函数值，至多 + 1。$\\pi(i-1)$表示着前一个状态匹配的最长真前后缀，也是下一个待匹配真前缀的最右元素下标。当且仅当 $s[i]=s[\\pi(i-1)]$，有$\\pi(i) = \\pi(i-1)+1$ 。\n考虑 $s[i] \\ne s[\\pi(i-1)]$，失配时，希望找到 $s[0] \\sim s[i-1]$ 中，仅次于 $\\pi[i-1]$ 的第二长度 $j$，使得在位置 $i-1$ 的前后缀性质仍然保持，即 $s[0] \\sim s[j-1] = s[i-j] \\sim s[i-1]$。\n实际上，第二长真后缀也完整存在于 当前真前缀 $s[0] \\sim s[j-1]$ 中，即有转移方程：$j^{(n-1)}=\\pi(j^n-1)$。所以如此往复，要么直到 $s[i]=s[j'] $ ，然后转移到第一种情况；要么直到 $j'=0$ 。两种情况，通过判断 $s[i] $ 是否 $s[j']$ 来确定要不要让 $j'+1$ 统一，最后 $s[i]=s[j']$。 1 2 3 4 5 6 7 8 9 10 def get_pi(s): n = len(s) pi = [0] * n for i in range(1, n): j = pi[i - 1] while j \u0026gt; 0 and s[i] != s[j]: j = pi[j - 1] if s[i] == s[j]: j += 1 pi[i] = j return pi KMP算法：找出 $p$ 在 $s$ 中的所有出现\n时间复杂度：$O(n+m)$，其中 $m=len(p),~n=len(s)$\n构造字符串 $t=p#s$，计算其前缀函数 $\\pi$。考虑前缀函数 $\\pi[m+1]\\sim \\pi[n+m]$，其中 $\\pi(i)=m $ 的地方，一定完成对模式串 $p$ 的匹配。此时，$i$ 位于 $t $ 中$s$ 的最后位置，所以原始位置为 $i-m+1-m-1 = i - 2 * m$。\n1 2 3 4 5 6 7 def kmp(p, s): res = [] m, n = len(p), len(s) pi = get_pi(p + \u0026#39;#\u0026#39; + s) for i in range(m + 1, len(pi)): if pi[i] == m: res.append(i - 2 * m) return res 字符串排序 1 2 sorted(str) #返回按照字典序排序后的列表，如\u0026#34;eda\u0026#34;-\u0026gt;[\u0026#39;a\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] s_sorted=\u0026#39;\u0026#39;.join(sorted(str))\t#把字符串列表组合成一个完整的字符串 Z函数 (扩展KMP) 对于字符串s，函数$z[i]$ 表示 $s$ 和 $s[i:]$ 的最长公共前缀$(LCP)$的长度。特别的，定义$z[0] = 0$。即 $$ z[i] = len(LCP(s,s[i:])) $$ 例如， $z(abacaba) = [0, 0, 1, 0, 3, 0, 1]$\n可视化：Z Algorithm (JavaScript Demo) (utdallas.edu)\n1 2 3 4 5 6 7 8 9 10 11 # s = \u0026#39;aabcaabxaaaz\u0026#39; n = len(s) z = [0] * n l = r = 0 for i in range(1, n): if i \u0026lt;= r: # 在Z-box范围内 z[i] = min(z[i - l], r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: l, r = i, i + z[i] z[i] += 1 # print(z) # [0, 1, 0, 0, 3, 1, 0, 0, 2, 2, 1, 0] 判断子序列 判断 p 在删除ss中下标元素后，是否仍然满足s 是 p 的子序列。\n1 2 3 4 例如： s = \u0026#34;abcacb\u0026#34;, p = \u0026#34;ab\u0026#34;, removable[:2] = [3, 1] 解释：在移除下标 3 和 1 对应的字符后，\u0026#34;abcacb\u0026#34; 变成 \u0026#34;accb\u0026#34; 。 \u0026#34;ab\u0026#34; 是 \u0026#34;accb\u0026#34; 的一个子序列。 1 2 3 4 5 6 7 8 ss = set(removable[:x]) i = j = 0 n, m = len(s), len(p) while i \u0026lt; n and j \u0026lt; m: if i not in ss and s[i] == p[j]: j += 1 i += 1 return j == m 字符串哈希 49. 字母异位词分组 - 力扣（LeetCode）\n2430. 对字母串可执行的最大删除数 - 力扣（LeetCode）\n字符串API s1.startswith(s2, beg = 0, end = len(s2))\n用于检查字符串s1 是否以字符串 s2开头。是则返回True。如果指定beg 和 end，则在s1[beg: end] 范围内查找。\n使用 ascii_lowercase遍历26个字母。\n1 2 from string import ascii_lowercase cnt = {ch: 0 for ch in ascii_lowercase} 区间问题 区间选点问题 / 最大不相交区间数量 射气球问题：给定 $n$ 个气球，用区间表示，选出最少的弓箭将所有气球都能射爆。\n区间选点问题：给定 $n$ 个区间，选出最少的点使得每个区间至少包含1个点。\n最大不相交区间问题：给定 $n$ 个区间，选出最多的区间，使得区间两两不相交（含端点）。\n这几个问题是等价的，最大不相交区间问题中，将区间集合 $U$ 划分成两两不相交的最多的区间集合 $S$ 和 $U-S$ 。任意 $U-S$ 中区间一定和 $S$ 中的区间相交，它们不需要额外占用更多的选点，因此 $|S|$ 就等于最少的弓箭数量、选点数量。\n对于 $mxr$ ，考察 $l, r$ 一共有三种情况：\n$mxr \u0026lt;l$，区间个数加一，$mxr = r$\n$l \\le mxr \u0026lt;r$，不变\n$r \\le mxr$，$mxr =r$\n综上，只需要在 $l \u0026gt; mxr$ 时，更新$res, mxr$，否则在 $r \u0026lt; mxr$ 时，更新 $mxr$ 。\n复杂度：$O(n)$\n452. 用最少数量的箭引爆气球 - 力扣（LeetCode）\n905. 区间选点 - AcWing题库\n908. 最大不相交区间数量 - AcWing题库\n1 2 3 4 5 6 7 8 9 10 11 def solve(nums): nums.sort() mxr = -inf res = 0 for l, r in nums: if l \u0026gt; mxr: res, mxr = res + 1, r elif r \u0026lt; mxr: mxr = r # 或者mxr = min(mxr, r) return res 区间分组 给定 $n$ 个区间，要求将其分成最少的组，每个组各个区间之间两两不相交（含端点）。\n维护所有分组的 $mxr$，对于 $mxr_{\\min}$ ，考察 $l$ 与之关系。\n$l \u0026gt; mxr_{\\min}$，可以放在这个分组中 $l \\le mxr_{\\min}$，需要开辟一个新的分组，最右端点是 $r$ 。 时间复杂度：$O(n \\log n)$\n906. 区间分组 - AcWing题库\n1 2 3 4 5 6 7 8 def solve(nums): nums.sort() hq = [] for l, r in nums: if hq and l \u0026gt; hq[0]: heappop(hq) heappush(hq, r) return len(hq) 区间覆盖 给定 $n$ 个区间和 一个需要覆盖的线段区间 $[L, R]$，找出最少的区间使它们完全覆盖线段区间 $[L,R]$；如果无法完成输出 -1。\n907. 区间覆盖 - AcWing题库\n考察当前已经覆盖到的最远端 $mxr$ ，考察所有 $l \\le mxr$，如果第一个 $l \u0026gt; mxr$，无法覆盖线段区间 $[mxr+1,]$记录这些区间的最远右端点 $nmxr$，然后更新 $mxr$ 。一旦超过 $R$ 表示完成覆盖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solve(L, R, nums): n = len(nums) nums.sort() mxr = L i = res = 0 while i \u0026lt; n: l, r = nums[i] if l \u0026gt; mxr: return -1 nmxr = r while i + 1 \u0026lt; n and nums[i + 1][0] \u0026lt;= mxr: nmxr = max(nmxr, nums[i + 1][1]) i += 1 res += 1 mxr = nmxr if mxr \u0026gt;= R: return res i += 1 return -1 合并区间 先排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: intervals.sort() res = [] l, r = intervals[0][0], intervals[0][1] for interval in intervals: il, ir = interval[0], interval[1] if il \u0026gt; r: res.append([l, r]) l = il r = max(r, ir) res.append([l, r]) return res 2580. 统计将重叠区间合并成组的方案数 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 def countWays(self, ranges: List[List[int]]) -\u0026gt; int: ranges.sort(key = lambda x: x[0]) l, r = ranges[0][0], ranges[0][1] nranges = [] for il, ir in ranges: if il \u0026gt; r: nranges.append([l, r]) l = il r = max(ir, r) 区间交集 Problem - C - Codeforces\n$Lo,Hi$ 记录当前可变温度区间。每次来到新时刻，更新为 $[Lo-dt,~Hi+dt]$。判断该区间是否和当前 $[lo, hi]$ 相交。是则求其交集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solve(): n, m = map(int, input().split()) tem = [(0, m, m)] for _ in range(n): at, lo, hi = map(int, input().split()) tem.append((at, lo, hi)) Lo = Hi = m for i in range(1, n + 1): at, lo, hi = tem[i] dt = at - tem[i - 1][0] Lo, Hi = Lo - dt, Hi + dt if Lo \u0026gt; hi or Hi \u0026lt; lo: return \u0026#39;NO\u0026#39; Lo, Hi = max(Lo, lo), min(Hi, hi) return \u0026#39;YES\u0026#39; 回溯 / 递归 / dfs / 分治 子集型回溯 枚举子集，$O(n\\cdot2^n)$\n78. 子集 - 力扣（LeetCode）\n回溯方法1：选 / 不选\n1 2 3 4 5 6 7 8 9 10 11 12 13 def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) res, path = [], [] def dfs(i): if i == n: res.append(path.copy()) return path.append(nums[i]) dfs(i + 1) path.pop() dfs(i + 1) dfs(0) return res 方回溯法2：枚举选哪个数 + 记录可以选的范围\n$dfs(i)$ 表示当前已经有选择了 $path$ 后，$path$ 下一个元素可以从 $i$ 及其往后选。每一个 $dfs$ 状态都是合法状态，需要记录。\n1 2 3 4 5 6 7 8 9 10 11 def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: res, path = [], [] n = len(nums) def dfs(i): res.append(path.copy()) for j in range(i, n): path.append(nums[j]) dfs(j + 1) path.pop() dfs(0) return res 位运算写法：\n1 2 3 4 5 6 7 8 9 def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) s = (1 \u0026lt;\u0026lt; n) - 1 res = [[]] sub = s while sub: res.append([nums[j] for j in range(n) if ((sub \u0026gt;\u0026gt; j) \u0026amp; 1)]) sub = (sub - 1) \u0026amp; s return res 组合型回溯 枚举所有长度为 $k$ 的组合\n77. 组合 - 力扣（LeetCode）\n回溯方法1：选 / 不选方法\n时间复杂度 ：$O(n \\cdot2^n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: nums = list(range(1, n + 1)) res, path = [], [] def dfs(i): if i == n: if len(path) == k: res.append(path.copy()) return # 不选 dfs(i + 1) # 选 path.append(nums[i]) dfs(i + 1) path.pop() dfs(0) return res 回溯方法2：枚举当前选哪个数，以及记录可以选择的范围，每一个状态的合法情况需要记录。\n剪枝操作 (1)：确保所有子集长度不会超过 $k$。剪枝操作 (2) ：要确保枚举当前选择的数的位置，不会使得最终整个子集长度达不到 $k$ 。通过两个剪枝操作，确保只会得到长度恰好为 $k$ 的子集。这里倒序 / 正序枚举在当前选择的数的范围影响下界 / 上界。\n倒序枚举时， $dfs(i)$ 表示当前选择范围为 $nums[0] \\sim nums[i]$，含有 $i+1$ 个数。由于下一个状态是 $j-1$，含有$ j$ 个数，根据 $j \\ge k - len(path)-1$ 计算下界。\n时间复杂度：$O(k \\cdot C(n,k))$。因为总共组合状态个数有 $C(n,k)$个，每个状态记录的长度不超过$k$ 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 倒叙枚举 def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: nums = list(range(1, n + 1)) res, path = [], [] def dfs(i): if k == len(path): res.append(path.copy()) return for j in range(i, k - len(path) - 2, -1): path.append(nums[j]) dfs(j - 1) path.pop() dfs(n - 1) return res 位运算写法 + Gosper\u0026rsquo;s Hack：\n时间复杂度：$O(n \\cdot C(n,k))$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: nums = list(range(1, n + 1)) s = (1 \u0026lt;\u0026lt; n) - 1 sub = (1 \u0026lt;\u0026lt; k) - 1 res = [] def next_sub(x): lb = x \u0026amp; -x left = x + lb right = ((left ^ x) \u0026gt;\u0026gt; 2) // lb return left | right while sub \u0026lt;= s: res.append([nums[i] for i in range(n) if (sub \u0026gt;\u0026gt; i) \u0026amp; 1]) sub = next_sub(sub) return res 完全背包型组合\n每个元素可以无限重复选择，需要找出目标值等于 $target$ （或小于等于 $target$ ）的所有可行组合。\n先排序，利于提前剪枝优化跳出循环。枚举当前选哪个 + 记录可以选择的范围型回溯，记录当前的和。由于可以重复选择，所以当前选择 $j$ 以后，下一次的可以选择范围仍然是 $j$。\n39. 组合总和 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def combinationSum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: candidates.sort() n, res, path = len(candidates), [], [] # 枚举当前选哪个，以及记录可以选择的范围；以及当前的和 def dfs(i, s): if s == target: res.append(path.copy()) return for j in range(i, n): x = candidates[j] if x + s \u0026lt;= target: path.append(x) dfs(j, s + x)\t# 体现可重复选择 path.pop() else: break dfs(0, 0) return res 括号生成问题：带限制组合型回溯\n22. 括号生成 - 力扣（LeetCode）\n选 / 不选型回溯：枚举当前左 / 右括号，记录当前左括号的个数。记 $lc$ 表示左括号个数， $rc$ 表示右括号个数。\n限制1：$lc$ 不能小于 $rc$。\n限制2：$lc $ 不能超过 $n/2$。\n限制3：当 $lc=rc$，只能回溯左括号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: # 枚举当前左 / 右括号，记录当前左括号的个数 n \u0026lt;\u0026lt;= 1 path = [None] * n res = [] def dfs(i, lc): rc = i - lc if rc \u0026gt; lc or lc \u0026gt; n // 2: return if i == n: res.append(\u0026#39;\u0026#39;.join(path)) return path[i] = \u0026#39;(\u0026#39; dfs(i + 1, lc + 1) if rc \u0026lt; lc: # 可以选右 path[i] = \u0026#39;)\u0026#39; dfs(i + 1, lc) dfs(0, 0) return res 时间复杂度：由于状态个数是卡特兰数列，即 $O(C_n) \\sim O(\\frac{4^n}{n^{\\frac{3}{2}} \\cdot\\sqrt \\pi})$\n排列型回溯 全排列：排列元素无重复\n46. 全排列 - 力扣（LeetCode）\n写法1：$dfs(i, S)$ 表示枚举到 第 $i$ 位，没有枚举过的集合为 $S$。外层 $path$ 表示当前回溯的路径。\n其中 $path$ 可以使用 $path[i] = j$ 的写法，覆盖当前走到哪一步；也可以使用 $append / pop$ 写法，覆盖和恢复现场。但是不可以在外层增加哈希集合维护没有枚举过的，这是因为集合添加操作的乱序性，外层的集合无法正确恢复现场（恢复后遍历顺序不正确）。\n时间复杂度：当有 $N$ 个数时，所有状态个数 $M = A_N^N+A_N^{N-1}+\\cdots+A_N^0=\\sum_{k=0}^{N}\\frac{N!}{k!} =N! \\cdot \\sum_{k=0}^{N}\\frac{1}{k!}= e\\cdot N!$。（麦克劳林展开）。每个状态时间复杂度，可以将集合的复制下方到下一个状态，所以是 $O(n)$。故总复杂度：$O(N \\cdot N!)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) path = [0] * n res = [] # 当前枚举到 位置 i，没有枚举过的集合为 S def dfs(i, S): if i == n: res.append(path.copy()) return for j in S: path[i] = j dfs(i + 1, S - {j}) dfs(0, set(nums)) return res 写法2：更偏向于回溯。外层$path$ 表示当前回溯的路径，外层 $on_path$ 维护节点是否已经出现在回溯的路径中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) path = [] on_path = [False] * n res = [] # 当前枚举到 位置 i，on_path 记录是否已经出现在回溯路径path中 def dfs(i): if i == n: res.append(path.copy()) return for pj, on in enumerate(on_path): if not on: on_path[pj] = True path.append(nums[pj]) dfs(i + 1) on_path[pj] = False path.pop() dfs(0) return res 全排列：排列元素有重复：只能用$on_path$ 回溯 / 位运算压缩\n47. 全排列 II - 力扣（LeetCode）\n相同元素，在 $i$处视为一个，加一个集合维护已经出现过的数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def permuteUnique(self, nums: List[int]) -\u0026gt; List[List[int]]: n, res = len(nums), [] path, on_path = [0] * n, [0] * n def dfs(i): if i == n: res.append(path.copy()) return S = set() # 相同元素，在i 处视为一个 for j, on in enumerate(on_path): if not on and nums[j] not in S: S.add(nums[j]) path[i] = nums[j] on_path[j] = 1 dfs(i + 1) on_path[j] = 0 dfs(0) return res 996. 正方形数组的数目 - 力扣（LeetCode）\n相同值的排列视为同一个：在枚举 $i$ 位置放谁的时候加一个集合维护已经出现过的数字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def numSquarefulPerms(self, nums: List[int]) -\u0026gt; int: n = len(nums) res = 0 def is_sqr(x): return x == int(sqrt(x)) ** 2 def dfs(i, S, pre): nonlocal res if i == n: res += 1 return # i 位置放谁 s = set() for j in range(n): x = nums[j] if (S \u0026gt;\u0026gt; j) \u0026amp; 1 == 1 or x in s: continue s.add(x) if pre == None or is_sqr(pre + x): dfs(i + 1, S | (1 \u0026lt;\u0026lt; j), x) dfs(0, 0, None) return res 2850. 将石头分散到网格图的最少移动次数 - 力扣（LeetCode）\n暴力枚举可重复全排列匹配 + 位运算压缩。用石头个数大于1 和 没有石头的位置，构造两个列表，进行全排列暴力匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def minimumMoves(self, grid: List[List[int]]) -\u0026gt; int: frm, to = [], [] for i, row in enumerate(grid): for j, x in enumerate(grid[i]): if x == 0: to.append((i, j)) elif x \u0026gt; 1: frm.extend((i, j) for _ in range(x - 1)) res = inf n = len(frm) path = [None] * n def dfs(i, S): nonlocal res if i == n: cst = sum(abs(x1 - x2) + abs(y1 - y2) for (x1, y1), (x2, y2) in zip(path, to)) res = min(res, cst) return for j in range(n): if (S \u0026gt;\u0026gt; j) \u0026amp; 1: path[i] = frm[j] dfs(i + 1, S ^ (1 \u0026lt;\u0026lt; j)) dfs(0, (1 \u0026lt;\u0026lt; n ) - 1) return res N皇后问题\n皇后之间不同行，不同列，且不能在同一斜线。如果只满足不同行不同列，等价于每行每列恰好一个皇后。如果用 $col$ 表示皇后的位置，$col[i]$ 表示 第 $i$ 行的皇后在第$col[i]$ 列，则 \u0026ldquo;每行每列恰好一个皇后\u0026rdquo; 等价于 枚举 $col$ 的全排列。\n加上斜线上不能有皇后的条件，如果从上往下枚举，则左上方向、右上方向不能有皇后。所以问题变成，当前枚举到 第 $i$ 行，可以枚举的列号的集合 $S$ 。枚举列$j \\in S$ ，合法情况即在 $\\forall r \\in [0 ,~ i-1]$ ，其列值 $c = col[r]$ 都不满足 $i+j=r+c$ 或者 $i-j=r-c$。\n写法1：$ dfs(i, S)$ 枚举当前到第 $i$ 行（选第$i$ 个数），可以选择的列号的集合是 $S$ （没选择过的数字集合S）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: res = [] path = [0] * n # 当前枚举到第 i 行，可以继续枚举的列号集合是 S def valid(i, j): for r in range(i): c = path[r] if r + c == i + j or r - c == i - j: return False return True def dfs(i, S): if i == n: res.append([\u0026#39;.\u0026#39; * j + \u0026#39;Q\u0026#39; + (n - j - 1) * \u0026#39;.\u0026#39; for j in path]) return for j in S: if valid(i, j): path[i] = j dfs(i + 1, S - {j}) dfs(0, set(range(n))) return res 写法2：回溯全排列 + 位运算 + 集合优化$O(1)$ 判断斜线方向\n由于判断 $i+j$ 和 $i - j$ 是否在之前回溯中出现过需要$O(n)$的时间，实际上只需要用集合记录出现过的 $i+j$ 和 $i - j$ 即可。对于出现过$i+j$ 和 $i-j$ 分别（防止相互干扰）放进集合 $lu$ 和$ru$ 中（由于 位运算中 $i-j$ 可能出现负值，所以存放的元素改成 $i-j+10$）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: res = [] path = [0] * n lu = ru = 0 # 当前枚举到第 i 行，可以继续枚举的列号集合是 S def dfs(i, S): nonlocal lu, ru if i == n: res.append([\u0026#39;.\u0026#39; * j + \u0026#39;Q\u0026#39; + (n - j - 1) * \u0026#39;.\u0026#39; for j in path]) return for j in range(n): if (S \u0026gt;\u0026gt; j) \u0026amp; 1 and (lu \u0026gt;\u0026gt; (i + j)) \u0026amp; 1 == 0 and (ru \u0026gt;\u0026gt; (i - j + 10)) \u0026amp; 1 == 0: path[i] = j lu, ru = lu | (1 \u0026lt;\u0026lt; (i + j)), ru | (1 \u0026lt;\u0026lt; (i - j + 10)) dfs(i + 1, S \u0026amp; ~(1 \u0026lt;\u0026lt; j)) lu, ru = lu ^ (1 \u0026lt;\u0026lt; (i + j)), ru ^ (1 \u0026lt;\u0026lt; (i - j + 10)) dfs(0, (1 \u0026lt;\u0026lt; n) - 1) return res 回溯分割字符串 记录当前切割到的位置，枚举下一个切割位置，判断切割合法性。\nLCR 086. 分割回文串 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def partition(self, s: str) -\u0026gt; List[List[str]]: n, path, res = len(s), [], [] # 当前分割的位置，枚举下次分割位置 def dfs(i): if i == n: res.append(path.copy()) return for j in range(i + 1, n + 1): t = s[i: j] if t == t[::-1]: path.append(t) dfs(j) path.pop() dfs(0) return res 93. 复原 IP 地址 - 力扣（LeetCode）\n增加了字符串段数限制：恰好等于4。时间复杂度：$O(n \\times C(n,3))$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def restoreIpAddresses(self, s: str) -\u0026gt; List[str]: n, path, res = len(s), [], [] # 记录当前分割位置，枚举下一个分割位置 def dfs(i): if len(path) == 4: if i == n: res.append(\u0026#39;.\u0026#39;.join(path)) return for j in range(i + 1, n + 1): t = s[i: j] if t == \u0026#39;0\u0026#39; or \u0026#39;0\u0026#39; not in t[0] and int(t) \u0026lt;= 255: path.append(t) dfs(j) path.pop() dfs(0) return res 2698. 求一个整数的惩罚数 - 力扣（LeetCode）\n判断一个数，其平方是否可能划分成若干字符串，其各段对应数字之和等于本身。例如 $36\\times36=1296,1+29+6=36$\n1 2 3 4 5 6 7 8 9 10 11 12 def check(x): sx = str(x * x) n = len(sx) def dfs(i, s): if i == n: return s == x t = 0 for j in range(i + 1, n + 1): t = t * 10 + int(sx[j - 1]) if t + s \u0026lt;= x and dfs(j, s + t): return True return False return dfs(0, 0) 分治 395. 至少有 K 个重复字符的最长子串 - 力扣（LeetCode）\n$f(s)$ 表示字符串s 中所有字符不少于 $k$ 个的子串中的最大长度。考察所有在当前 $s$ 串中出现次数少于 $k$ 的字符（记作分割字符），最终最大串肯定不包含之。因此，每一层递归，以找到的第一个分割字符作为隔板，将 $s$ 分成 若干个小的子串，取其中最大值即可。\n时间复杂度：$O(26N)$，这是由于每一层递归必然完全删除一个小写字母，且每一层需要遍历整个字符串，时间复杂度是$O(N)$；所以总复杂度是 $O(26N)$。\n1 2 3 4 5 6 7 8 9 def longestSubstring(self, s1: str, k: int) -\u0026gt; int: # s1中所有字符数量 \u0026gt;= k 个最长子串 def f(s1): cnt = Counter(s1) for ch, c in cnt.items(): if c \u0026lt; k: return max(f(sub) for sub in s1.split(ch)) return len(s1) return f(s1) 1763. 最长的美好子字符串 - 力扣（LeetCode）\n$f(s)$ 表示字符串 $s$ 中所有字符出现大小写的最长子串。以 $s1$ 中只出现大写 / 小写的字母作为分割点，将问题分治，返回最大长度中出现最早的字符串。时间复杂度：$O(26 \\times n)$，因为每一层需要 $O(n)$ 的复杂度，每一层递归至少减少一个字符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from collections import * from string import ascii_lowercase, ascii_uppercase L, U = ascii_lowercase, ascii_uppercase def f(s1): s = set(s1) for l, u in zip(L, U): if (l in s) != (u in s): ss = s1.split(l if l in s else u) res = \u0026#39;\u0026#39; for sub in ss: cur = f(sub) if len(cur) \u0026gt; len(res): res = cur return res return s1 class Solution: def longestNiceSubstring(self, s: str) -\u0026gt; str: return f(s) 排序 次最值问题\n1289. 下降路径最小和 II - 力扣（LeetCode）\n其中需要维护上一层的最小值、次小值及其对应的坐标。\n1 2 3 4 mn = mn_2 = (inf, -1) if y \u0026lt; mn[0]: mn_2, mn = mn, (y, j) elif y == mn[0]: mn_2 = (y, j) elif y \u0026lt; mn_2[0]: mn_2 = (y, j) 计数排序 带修求第 $k$ 小 / 大的数\n使用哈希表维护每个数值出现次数，适用于数值的值域较小的情况。\n例如：当 $nums[i] \\in [a,~b]$，可以在 $O(b-a)$ 的时间复杂度内，找出第 $k$ 大的数（有时表现会比 SortedList更好）。\n1 2 3 4 5 6 7 def get_min_k(cnt, k): cur = 0 for x in range(a, b): if cnt[x] == 0: continue cur += cnt[x] if cur \u0026gt;= k: return x return b 2653. 滑动子数组的美丽值 - 力扣（LeetCode）\n定长滑动窗口 + 哈希维护计数 + 计数排序。时间复杂度：$O(nU),U$ 是值域极差。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -\u0026gt; List[int]: n = len(nums) cnt = Counter(nums[:k]) def get_min_k(): cur = 0 for y in range(-50, 0): cur += cnt[y] if cur \u0026gt;= x: return y return 0 res = [get_min_k()] for r in range(k, n): nl, nr = nums[r - k], nums[r] cnt[nr] += 1 cnt[nl] -= 1 if cnt[nl] == 0: cnt.pop(nl) res.append(get_min_k()) return res 离散化 二分写法\n1 2 sorted_nums = sorted(set(nums)) nums = [bisect.bisect_left(sorted_nums, x) + 1 for x in nums] 字典写法\n1 2 3 sorted_nums = sorted(set(nums)) mp = {x: i + 1 for i, x in enumerate(sorted_nums)} nums = [mp[x] for x in nums] 二分 + 还原\n1 2 3 4 tmp = nums.copy() sorted_nums = sorted(set(nums)) nums = [bisect.bisect_left(sorted_nums, x) + 1 for x in nums] mp_rev = {i: x for i, x in zip(nums, tmp)} 二分查找 1 2 3 4 5 6 7 8 from bisect import * l = [1,1,1,3,3,3,4,4,4,5,5,5,8,9,10,10] print(len(l)) # 16 print(bisect(l, 10)) # 相当于upper_bound, 16 print(bisect_right(l, 10)) # 16 print(bisect_left(l, 10)) # 14 多维二分 1 2 a = [(1, 20), (2, 19), (4, 15), (7,12)] idx = bisect_left(a, (2, )) # 1 二分答案 正难则反思想，二分答案一般满足两个条件：\n当发现问需要的最少/最多时间时 答案具有单调性。例如问最少的时候，你发现取值越大越容易满足条件。 check(x) 函数对单调x 进行检验。\n1 2 3 4 5 6 7 y = 27 def check(x): if x \u0026gt; y: return True return False left = a res = left + bisect.bisect_left(range(left, mx), True, key = check)) 3048. 标记所有下标的最早秒数 I - 力扣（LeetCode）\n求“至少”问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 n, m = len(nums), len(changeIndices) def check(mx): # 给mx天是否能顺利考完试 last_day = [-1] * n for i, x in enumerate(changeIndices[:mx]): last_day[x - 1] = i + 1 #如果给mx不能完成，等价于有为i遍历到考试日期的考试 if -1 in last_day: return False less_day = 0 for i, x in enumerate(changeIndices[:mx]): if last_day[x - 1] == i + 1: # 到了考试日期 if less_day \u0026gt;= nums[x - 1]: less_day -= nums[x - 1] less_day -= 1 #抵消当天不能复习 else: return False #寄了 less_day += 1 return True left = sum(nums) + n # 至少需要的天数, 也是二分的左边界 res = left + bisect.bisect_left(range(left, m + 1), True, key = check) return -1 if res \u0026gt; m else res 求“最多”问题\n1642. 可以到达的最远建筑 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -\u0026gt; int: n = len(heights) d = [max(0, heights[i + 1] - heights[i]) for i in range(n - 1)] def check(x): t = d[:x] t.sort(reverse = True) return not (ladders \u0026gt;= x or sum(t[ladders: ]) \u0026lt;= bricks) return bisect.bisect_left(range(n), True, key = check) - 1 中位数转化为第 $k$ 小问题\n对于一个长度为 $n$ 的 由于数组，求中位数等价于求数组中第 $\\frac{n-1}{2}$ 小的数问题（广义中位数）。\n3134. 找出唯一性数组的中位数 - 力扣（LeetCode）\n一共有 $(n + 1) \\times n / 2$ 个子数组，其对应的 $f=len (set(sub))$ 的值按照升序排列后，求其中位数。即转换为求数组中 第 $k$ 小问题。\n转换为二分查找：给定一个 $x$ ，能得出所有子数组中 $f$ 值小于等于 $x$ 的个数 $res$；可以发现 $x$ 越大，$res$ 越大；因此找到恰好让$res \u0026gt;k$ 的位置即可。这里需要使用到求**“不同元素个数小于等于 $k$ 的子数组个数”** 问题，这是一共广义上不定长滑动窗口问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def get_set_subarrays_lower_k(nums, k): l = res = 0 freq = Counter() for r, x in enumerate(nums): freq[x] += 1 while len(freq) \u0026gt; k: freq[nums[l]] -= 1 if freq[nums[l]] == 0: freq.pop(nums[l]) l += 1 res += r - l + 1 return res class Solution: def medianOfUniquenessArray(self, nums: List[int]) -\u0026gt; int: n = len(nums) m = ((n + 1) * n // 2 - 1) // 2 lo, hi = 0, n // 2 + 10 while lo \u0026lt; hi: mid = (lo + hi) // 2 if get_set_subarrays_lower_k(nums, mid) \u0026gt; m: hi = mid else: lo = mid + 1 return lo 朴素二分 在 闭区间[a, b]上二分\n1 2 3 4 5 6 7 8 lo, hi = a, b # [a, b] while lo \u0026lt; hi: mid = (lo + hi) // 2 if check(mid): hi = mid else: lo = mid + 1 return lo 实现bisect_left\n注意：查找范围为$[lo, hi]$；当 $x\u0026gt;max(nums[lo:hi +1])$ 时，结果 $lo$ 值 等于 $hi$ 。\n$bisect_left(nums, x + 1, lo, hi)-1$ 查找闭区间$[lo,hi]$内，恰好大于 $x$ 的首个位置。如果不存在时，$lo = hi$ ，注意需要特判。\n当$hi = n$ 时，兼容了存在和不存在两种情况。当不存在时，$lo=n$。\n1 2 3 4 5 6 7 8 9 10 11 12 def bisect_left(nums, x, lo, hi): def check(pos): return nums[pos] \u0026gt;= x while lo \u0026lt; hi: # 查找恰好比x大于等于的位置 mid = (lo + hi) \u0026gt;\u0026gt; 1 if check(mid): hi = mid else: lo = mid + 1 return lo print(bisect_left(nums, val, 0, len(nums))) 2563. 统计公平数对的数目 - 力扣（LeetCode）同 Problem - 1538C - Codeforces\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def countFairPairs(self, nums: List[int], lower: int, upper: int) -\u0026gt; int: n = len(nums) nums.sort() res = 0 L, R = lower, upper def bisect_left1(nums, x, lo, hi): while lo \u0026lt; hi: mid = (lo + hi) \u0026gt;\u0026gt; 1 if nums[mid] \u0026gt;= x: hi = mid else: lo = mid + 1 return lo for i, x in enumerate(nums): res += bisect_left1(nums, R - x + 1, i + 1, n) - 1 - bisect_left1(nums, L - x, i + 1, n) + 1 return res 自定义比较规则 1 2 3 4 5 6 7 class node(): def __init__(self, need, get, idx): self.need = need self.get = get self.idx = idx def __lt__(self, other): return self.need \u0026lt; other.need 滑动窗口 定长滑动窗口 维护定长滑动窗口和\n1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 def numOfSubarrays(self, nums: List[int], k: int, t: int) -\u0026gt; int: n = len(nums) s = sum(nums[ :k]) res = 1 if s / k \u0026gt;= t else 0 for r in range(k, n): s = s + nums[r] - nums[r - k] if s / k \u0026gt;= t: res += 1 return res 2134. 最少交换次数来组合所有的 1 II - 力扣（LeetCode）\n将环形数组中所有1聚集到一起的最小交换位置次数，即长度为 $k$ (字符串中1的个数)的滑动窗口中，0个数最少的位置处。\n1 2 3 4 5 6 7 8 9 10 11 def minSwaps(self, nums: List[int]) -\u0026gt; int: k = nums.count(1) if k == 0: return 0 nums = nums + nums n = len(nums) s = sum(nums[:k]) res = k - s for r in range(k, n): s = s + nums[r] - nums[r - k] res = min(res, k - s) return res 维护定长滑动窗口 + 字典计数\n567. 字符串的排列 - 力扣（LeetCode）\n判断字符串 $s1$ 中是否包含 $s2$ 的一个排列：转化为判断是否存在两个字典计数情况相等。\n1 2 3 4 5 6 7 8 9 10 11 def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: k, n = len(s1), len(s2) target = Counter(s1) cur = Counter(s2[ :k]) if target == cur: return True for r in range(k, n): rch, lch = s2[r], s2[r - k] cur[rch] += 1 cur[lch] -= 1 if target == cur: return True return False 438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n找出字符串 $s1$ 中所有 $s2$ 的排列的下标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def findAnagrams(self, s: str, p: str) -\u0026gt; List[int]: res = [] k, n = len(p), len(s) target = Counter(p) cur = Counter(s[ :k]) if cur == target: res.append(0) for r in range(k, n): lch, rch = s[r - k], s[r] cur[rch] += 1 cur[lch] -= 1 if cur == target: res.append(r - k + 1) return res 2841. 几乎唯一子数组的最大和 - 力扣（LeetCode）\n通过 $Counter()$ 维护滑动窗口中，不同元素的个数。（即 $len(set(win))$\n1 2 3 4 5 6 7 8 9 10 11 12 13 def maxSum(self, nums: List[int], m: int, k: int) -\u0026gt; int: s = sum(nums[ :k]) cnt = Counter(nums[ :k]) res = s if len(cnt) \u0026gt;= m else 0 n = len(nums) for r in range(k, n): nl, nr = nums[r - k], nums[r] s = s + nr - nl cnt[nr] += 1 cnt[nl] -= 1 if cnt[nl] == 0: cnt.pop(nl) if len(cnt) \u0026gt;= m and s \u0026gt; res: res = s return res 2009. 使数组连续的最少操作数 - 力扣（LeetCode）\n定长滑动窗口 + 正难则反：需要操作最少次数 = n - 能够不操作的最多的数字。这些数字显然是不重复的，所以首先去重。对于去重完的元素，每一个左边界$ nums[left]$, 在去重数组中 ，$[nums[left] ,~ nums[left] + n - 1]$ 区间在数组中出现的次数即为当前可以保留的数字的个数。\n1 2 3 4 5 6 7 8 9 def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) res = left = 0 for i, x in enumerate(nums): while x \u0026gt; nums[left] + n - 1: left += 1 res = max(res, i - left + 1) return n - res 1423. 可获得的最大点数 - 力扣（LeetCode）\n定长滑动窗口 + 正难则反：要求前 + 后 的个数为定值 $k$ 个，转换为中间为 $n-k$ 个。\n1 2 3 4 5 6 7 8 9 10 def maxScore(self, nums: List[int], k: int) -\u0026gt; int: n, tot = len(nums), sum(nums) if n == k: return tot k = n - k s = sum(nums[:k]) res = s for r in range(k, n): s = s + nums[r] - nums[r - k] res = min(res, s) return tot - res 不定长滑动窗口 和大于等于 $k$ 的最短数组（最短长度）\n209. 长度最小的子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 def minSubArrayLen(self, k: int, nums: List[int]) -\u0026gt; int: l = s = 0 res = inf for r, x in enumerate(nums): s += x while s \u0026gt;= k: res = min(res, r - l + 1) s, l = s - nums[l], l + 1 return res if res \u0026lt; inf else 0 2904. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）\n求包含恰好 $k$ 个 1的所有子串中，最短、字典序最小的：转换为 和大于等于 $k$ 的最短数组问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def shortestBeautifulSubstring(self, s1: str, k: int) -\u0026gt; str: if s1.count(\u0026#39;1\u0026#39;) \u0026lt; k: return \u0026#39;\u0026#39; n = len(s1) l = s = 0 resl, resr = 0, n for r, ch in enumerate(s1): s += int(ch) while s \u0026gt;= k: width = r - l + 1 if width \u0026lt; resr - resl + 1 or (width == resr - resl + 1 and s1[l: r + 1] \u0026lt; s1[resl: resr + 1]): resl, resr = l, r s, l = s - int(s1[l]), l + 1 return s1[resl: resr + 1] 和小于等于 $k$ 的最长子数组（最大长度）\n1493. 删掉一个元素以后全为 1 的最长子数组 - 力扣（LeetCode）\n$s$ 统计0的个数，转换为 $s \\le 1 $ 的最长子数组长度。\n1 2 3 4 5 6 7 8 9 10 11 12 def longestSubarray(self, nums: List[int]) -\u0026gt; int: res = 0 l = s = 0 # s \u0026lt;= 1 的最长子数组 for r, x in enumerate(nums): s += 1 if x == 0 else 0 while s \u0026gt; 1: s -= 1 if nums[l] == 0 else 0 l += 1 if s \u0026lt;= 1: res = max(res, r - l) return res 2730. 找到最长的半重复子字符串 - 力扣（LeetCode）\n预处理相邻字符相等情况，转换为 $s \\le 1$ 的最长字串。\n1 2 3 4 5 6 7 8 9 10 11 12 def longestSemiRepetitiveSubstring(self, s1: str) -\u0026gt; int: l = s = 0 res = 0 nums = [1 if s1[i] == s1[i - 1] else 0 for i in range(1, len(s1))] # s \u0026lt;= 1 的最长子串 for r, x in enumerate(nums): s += x while s \u0026gt; 1: s -= nums[l] l += 1 res = max(res, r - l + 1) return res + 1 不包含重复元素的子数组（最长长度 / 最大和）\n包含重复元素的条件是 $len(win) \u0026lt; r - l+1$。\n3. 无重复字符的最长子串 - 力扣（LeetCode）\n方法一：使用 $d$ 字典维护元素出现的最新位置。当 $d[ch]$ 出现在 $[l,~r]$ 区间内表示需要更新 $l=d[ch]+1$。\n1 2 3 4 5 6 7 8 9 def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: d = defaultdict(lambda: -inf) l = res = 0 for r, ch in enumerate(s): if d[ch] \u0026gt;= l: l = d.pop(ch) + 1 d[ch] = r res = max(res, r - l + 1) return res 方法二：\n不包含重复元素的条件是 $len(win) = r - l+1$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: res = 0 l = 0 cnt = Counter() for r, ch in enumerate(s): cnt[ch] += 1 while len(cnt) \u0026lt; r - l + 1: lch = s[l] cnt[lch] -= 1 if cnt[lch] == 0: cnt.pop(lch) l += 1 res = max(res, r - l + 1) return res 1695. 删除子数组的最大得分 - 力扣（LeetCode）\n不包含重复元素的子数组的最大和。不包含重复元素的条件是 $len(win) = r - l+1$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def maximumUniqueSubarray(self, nums: List[int]) -\u0026gt; int: res = 0 l = s = 0 cnt = Counter() for r, x in enumerate(nums): cnt[x] += 1 s += x while len(cnt) \u0026lt; r - l + 1: nl = nums[l] s -= nl cnt[nl] -= 1 if cnt[nl] == 0: cnt.pop(nl) l += 1 res = max(res, s) return res 2401. 最长优雅子数组 - 力扣（LeetCode）\n不定长滑窗 + 位运算。\n子数组中所有数两两 $AND$都是 $0$，要求子数组所有比特位上是 $1$ 的个数最多是 $1$ 。用 $ors$ 维护滑窗中的 $OR$ 值， $r$ 能加入子数组需要满足 $r~ \u0026amp; ~ors = 0$。（因为 $a | (b \u0026amp; c) = (a \u0026amp;b) | (a \u0026amp; c)=0 $，即与子数组中所有数相与都是0）。而从子数组中删去 $left$ 只需要做异或操作，因为已经确保了 $ors$ 比特位上面每个 $1$ 都是独属的。\n1 2 3 4 5 6 7 8 9 10 11 12 def longestNiceSubarray(self, nums: List[int]) -\u0026gt; int: # nums[i] \u0026lt;= 1e9，30个二进制bit位上 ors = 0 l = 0 res = 0 for r, x in enumerate(nums): while x \u0026amp; ors \u0026gt; 0: ors ^= nums[l] l += 1 ors |= x res = max(res, r - l + 1) return res 子数组合法方案数问题\n先更新滑动窗口状态（广义上），检查、剔除不合法的元素（如窗口左边界右移、计数器减一等），累积上 $res$ 的方案数（等于窗口长度）。\n乘积小于 $k$ 的子数组的个数（方案数）\n713. 乘积小于 K 的子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 def numSubarrayProductLessThanK(self, nums: List[int], k: int) -\u0026gt; int: if k \u0026lt;= 1: return 0 res = 0 l, prod = 0, 1 for r, x in enumerate(nums): prod *= x while prod \u0026gt;= k: prod, l = prod / nums[l], l + 1 res += r - l + 1 return res 不同值个数小于等于 $k$ 的子数组个数（方案数）\n使用 $freq$ 计数器维护元素出现个数、左边界 $l$ 。当\n3134. 找出唯一性数组的中位数 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 # 计算不同值元素个数小于对于k 的子数组个数 def get_set_subarrays_lower_k(nums, k): l = res = 0 freq = Counter() for r, x in enumerate(nums): freq[x] += 1 while len(freq) \u0026gt; k: freq[nums[l]] -= 1 if freq[nums[l]] == 0: freq.pop(nums[l]) l += 1 res += r - l + 1 return res 不定长滑窗 + 哈希计数 不定长滑窗哈希表：所有 $freq[x] \\le k$ 的最长子数组，由于单次判断的时间复杂度是 $O(n)$，总复杂度是 $O(n^2) $。 通过 $cnt$ 维护 $freq[x] \u0026gt; k$ 的个数，在边界处增减1。转换为 $cnt = 0$ 最长子数组 ，复杂度 $O(n) $\n2958. 最多 K 个重复元素的最长子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def maxSubarrayLength(self, nums: List[int], k: int) -\u0026gt; int: # 所有freq[x] \u0026lt;= k 的最长子数组 # 转换为 cnt == 0 最长子数组 （cnt 为 freq[x] \u0026gt; k 的个数） freq = Counter() l = res = cnt = 0 for r, x in enumerate(nums): cnt += int(freq[x] == k) freq[x] += 1 while cnt \u0026gt; 0: nl = nums[l] cnt -= int(freq[nl] == k + 1) freq[nl] -= 1 l += 1 res = max(res, r - l + 1) return res Problem - 1777C - Codeforces\n不定长滑窗 + 哈希计数。首先对 $nums$ 数组排序 + 去重，对于 $m=1$ 的情况直接返回 $0$ ；否则要求 $2 \\sim m $ 中的每一个数，都在滑动窗口中的所有因子构成的集合中出现一次。因为需要维护滑窗集合，所以采用滑窗 + 哈希， $freq$ 维护滑窗中所有数的因子的出现个数。由于需要 $2 \\sim m $ 中均有 $freq[x] \\ge 1$ ，每次判断需要 $O(n)$ 的复杂度，总体是 $O(mn)$ ，无法接受。因此使用 $cnt$ 统计 $freq[x] \\ge 1$ 的个数，$cnt $ 在边界情况时增减1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from collections import * from math import * import sys input = lambda: sys.stdin.readline().strip() # 预处理 2 ~ mx中所有数的约数的列表 mx = 100001 factors = [[] for _ in range(mx)] for i in range(2, mx): for j in range(i, mx, i): factors[j].append(i) t = int(input()) def solve(): n, m = map(int, input().split()) nums = list(set(map(int, input().split()))) nums.sort() if m == 1: return 0 # 2, 3, ... , m # 求所有滑窗中，freq[2...m] \u0026gt;= 1 的最小极差。 # 用cnt统计 freq[x] \u0026gt;= 1 的个数，求 cnt == m - 1 的滑窗的最小极差 freq = Counter() l = cnt = 0 res = inf for r, x in enumerate(nums): for y in factors[x]: if y \u0026gt; m: break if freq[y] == 0: cnt += 1 freq[y] += 1 while cnt == m - 1: nl = nums[l] res = min(res, x - nl) for y in factors[nl]: if y \u0026gt; m: break if freq[y] == 1: cnt -= 1 freq[y] -= 1 l += 1 return res if res \u0026lt; inf else -1 for _ in range(t): print(solve()) 枚举型滑窗 / 分组滑窗 枚举出现种类个数\n枚举 + 不定长滑窗 + 哈希计数\n显然 $k=1$ 时，原串满足条件直接返回其长度。\n考虑 $k\u0026gt;1$，要求子串中所有字符个数 $\\ge k$，假设 $s1[l\\sim r]$ 满足条件，考虑 $s1[r+1]$，如果是在 $s1$ 中出现过的字符，一定满足；否则一定不满足条件，此时不确定滑窗的左边界 $l$ 是否需要右移，例如 $\u0026lsquo;bbaaacb\u0026rsquo;$，当 $r=4$ 时，由于后续的 $c$ 的出现会导致 无法凑出 $bbaaab$，因此需要左移。这实际上比较难以确定。\n然而，如果限制 / 约束了子串中不同字母的种类个数 $c$，并依次枚举 $c \\in [1, 26]$，对于每个 $c$，采用不定长滑窗 + 哈希计数的方式，可以唯一确定是否需要左移左边界。实现时，需要维护子串中每个字符出现的频次 $freq$、出现且次数不够 $k$ 的字符的个数 $cnt$、字符的种类个数 $tcnt$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def longestSubstring(self, s1: str, k: int) -\u0026gt; int: if k == 1: return len(s1) n = len(s1) res = 0 # 枚举滑窗 for c in range(1, len(set(s1)) + 1): # 滑窗中字母种类个数恰好为 c freq = Counter() cnt = 0 # 哈希计数 tcnt = 0 # 种类计数 l = 0 for r, ch in enumerate(s1): if freq[ch] == 0: cnt += 1 tcnt += 1 if freq[ch] == k - 1: cnt -= 1 freq[ch] += 1 while tcnt \u0026gt; c: lch = s1[l] if freq[lch] == k: cnt += 1 if freq[lch] == 1: tcnt -= 1 cnt -= 1 freq[lch] -= 1 l += 1 if tcnt == c and cnt == 0: res = max(res, r - l + 1) return res 时间复杂度：$O(26N)$\n2953. 统计完全子字符串 - 力扣（LeetCode）\n定长滑窗 + 枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def countCompleteSubstrings(self, s1: str, k: int) -\u0026gt; int: res = 0 # s 中每个字符恰好出现 k 次的子串个数 def f(s): # # 枚举字符种类个数 m = len(set(s)) n = len(s) res = 0 # 由于是恰好 k个，所以滑窗长度为 c * k for c in range(1, m + 1): K = c * k if K \u0026gt; n: break freq = Counter() cnt = 0 # 等于 k 的个数 for i in range(K): ch = s[i] if freq[ch] == k - 1: cnt += 1 elif freq[ch] == k: cnt -= 1 freq[ch] += 1 res += int(cnt == c) for r in range(K, n): ch, lch = s[r], s[r - K] if lch != ch: if freq[ch] == k - 1: cnt += 1 elif freq[ch] == k: cnt -= 1 if freq[lch] == k: cnt -= 1 elif freq[lch] == k + 1: cnt += 1 freq[ch] += 1 freq[lch] -= 1 if freq[lch] == 0: freq.pop(lch) res += int(cnt == c) return res sub = \u0026#39;\u0026#39; for ch in s1: if sub and abs(ord(ch) - ord(sub[-1])) \u0026gt; 2: res += f(sub) sub = ch else: sub += ch res += f(sub) return res 时间复杂度：$O(26N)$\n枚举多起点\n分组滑窗\n2831. 找出最长等值子数组 - 力扣（LeetCode）\n按元素对下标分组 + 不定长滑窗\n预处理每个元素所有下标构成的数组，对某一元素 $x$，其数组 $a$ 上做不定长滑窗，$a[r] - a[l] + 1$ 为滑窗长度，$r-l+1$ 为 $x$ 个数。因为最多能删除 $k$ 个，所以要求 $ a[r] - a[l] + 1 - (r - l + 1) \\le k$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def longestEqualSubarray(self, nums: List[int], k: int) -\u0026gt; int: d = defaultdict(list) for i, x in enumerate(nums): d[x].append(i) res = 1 for a in d.values(): m = len(a) l = 0 for r in range(m): while a[r] - a[l] + 1 - (r - l + 1) \u0026gt; k: l += 1 res = max(res, r - l + 1) return res 双指针 相向双指针\n2105. 给植物浇水 II - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def minimumRefill(self, nums: List[int], A: int, B: int) -\u0026gt; int: n = len(nums) i, j = 0, n - 1 a, b = A, B res = 0 while i \u0026lt;= j: l, r = nums[i], nums[j] if i \u0026lt; j: if a \u0026lt; l: a = A - l res += 1 else: a -= l if b \u0026lt; r: b = B - r res += 1 else: b -= r else: x = max(a, b) if x \u0026lt; l: res += 1 i, j = i + 1, j - 1 return res 同向双指针\n1574. 删除最短的子数组使剩余数组有序 - 力扣（LeetCode）\n同向双指针 + 贪心。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def findLengthOfShortestSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) l, r = 0, n - 1 while l + 1 \u0026lt; n and nums[l] \u0026lt;= nums[l + 1]: l += 1 if l == n - 1: return 0 while r - 1 \u0026gt;= 0 and nums[r - 1] \u0026lt;= nums[r]: r -= 1 res, mxl = r, l for l in range(mxl + 1): while r \u0026lt; n and nums[r] \u0026lt; nums[l]: r += 1 res = min(res, r - l - 1) return res 1163. 按字典序排在最后的子串 - 力扣（LeetCode）\n转换问题：子串中字典序最大的串\n性质1： 后缀 $s[i:]$ 是以 $s[i]$ 为开头的子串中，字典序最大的串。\n性质2：考察字典序最大的串，记为 $sub$，它的每个字符都小于等于 $sub[0]$。\n例如，\u0026lsquo;ycyba\u0026rsquo; 是一个可能的最大串，而 \u0026lsquo;yczba\u0026rsquo;就不是，因为 \u0026lsquo;zba\u0026rsquo; \u0026gt; \u0026lsquo;yczba\u0026rsquo;。\n对于两个位置 $i,j$，用偏移 $k$ 考察 $s[i:] $ 和 $s[j:]$ 中各个字符的大小关系：\n$s[i+k] = s[j+k]$，则继续往后考察，$k+1$；\n$s[i+k] \u0026lt; s[j+k]$，应让 $i$ 跳到 $\\max (i+k+1, j)$。\n首先可以肯定 $[i+1, i+k]$ 都不需要考虑，这是因为由于性质1，2，所以以 $[i+1, i+k]$ 开头的子串一定比 $s[i \\sim i+k]$ 小； 其次，如果 $i+k+1 \\le j$，则 $j$ 应该曾经已经考虑过 $[i+k+1, j - 1]$ 区间了，他们都没能更新 $i$ ，一定比 $s[i:i+k]$ 小 最后，如果 $i+k+1\u0026gt;j$ ，例如 \u0026lsquo;yybbyybbyyc\u0026rsquo; 这种情况，$s[i:i+k] = yybbyyb$，$s[j:j+k] = yybbyyc$，有公共前缀 $yybbyy$ ，以及后缀 $yyc$，即 $[j, i + k]$ 区间一定回比后缀小。 所以， $i = \\max(i+k+1, j)$, $j = i + 1, k = 0 $。\n$s[i+k] \u0026gt; s[j+k]$，让 $j$ 跳到 $j+k+1, k = 0$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def lastSubstring(self, s: str) -\u0026gt; str: i, j, k = 0, 1, 0 n = len(s) while j + k \u0026lt; n: if s[i + k] == s[j + k]: k += 1 else: if s[i + k] \u0026lt; s[j + k]: i = j if j \u0026gt; i + k + 1 else i + k + 1 j = i + 1 else: # s[i + k] \u0026gt; s[j + k]: j += k + 1 k = 0 return s[i: ] 分组循环 适用于：数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。\n核心思想：\n外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。 内层循环负责遍历组，找出这一组最远在哪结束。 模板：\n1 2 3 4 5 6 7 8 9 10 n = len(nums) i = 0 while i \u0026lt; n: start = i while i \u0026lt; n and ...: i += 1 # 从 start 到 i-1 是一组 # 下一组从 i 开始，无需 i += 1 ans = max(ans, i - start) 时间复杂度：$O(n)$\n2760. 最长奇偶子数组 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def longestAlternatingSubarray(self, nums: List[int], k: int) -\u0026gt; int: n = len(nums) i = res = 0 while i \u0026lt; n: x = nums[i] if x \u0026gt; k or x \u0026amp; 1: i += 1 continue start = i i += 1 while i \u0026lt; n and nums[i] \u0026lt;= k and nums[i - 1] \u0026amp; 1 != nums[i] \u0026amp; 1: i += 1 res = max(res, i - start) return res 单调结构 单调栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def trap(self, height: List[int]) -\u0026gt; int: # 单调栈：递减栈 stk, n, res = deque(), len(height), 0 for i in range(n): # 1.单调栈不为空、且违反单调性 while stk and height[i] \u0026gt; height[stk[-1]]: # 2.出栈 top = stk.pop() # 3.特判 if not stk: break # 4.获得左边界、宽度 left = stk[-1] width = i - left - 1 # 5.计算 res += (min(height[left], height[i]) - height[top]) * width # 6.入栈 stk.append(i) return res 84. 柱状图中最大的矩形 - 力扣（LeetCode）\n矩形面积求解：维护单调增栈，同时首尾插入哨兵节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: heights.append(-1) stk = [-1] res = 0 for i, h in enumerate(heights): while len(stk) \u0026gt; 1 and h \u0026lt; heights[stk[-1]]: cur = stk.pop() l = stk[-1] width = i - l - 1 s = width * heights[cur] res = max(res, s) stk.append(i) return res 1793. 好子数组的最大分数 - 力扣（LeetCode）\n矩形面积求解问题变形：求 $min(nums[i], ~ \\cdots~, nums[j]) \\times (j -i+1)$ ，并对$i, ~j $ 做了范围约束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def maximumScore(self, nums: List[int], k: int) -\u0026gt; int: stk = [-1] nums.append(-1) res = 0 for i, h in enumerate(nums): while len(stk) \u0026gt; 1 and h \u0026lt; nums[stk[-1]]: cur = stk.pop() l = stk[-1] if not(l + 1 \u0026lt;= k and i - 1 \u0026gt;= k): continue\t# 约束范围 width = i - l - 1 res = max(res, width * nums[cur]) stk.append(i) return res 单调栈维护元素的左右山形边界\n对于 $a[i]=x$ ，希望找到在左侧中的最小 $l$ 满足 $a[l + 1] \\sim a[i-1] \\ge 或者 \\le x$；\n对于 $a[i]=x$ ，希望找到在右侧中的最大 $r$ 满足 $a[i + 1] \\sim a[r-1] \\ge 或者 \\le x$；\n1 2 3 4 5 6 7 8 9 10 11 12 stk, left = [], [-1] * n for i in range(n): x = nums[i] while stk and x \u0026lt;= nums[stk[-1]]: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk, right = [], [n] * n for i in range(n - 1, -1, -1): x = nums[i] while stk and x \u0026lt;= nums[stk[-1]]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) 2334. 元素值大于变化阈值的子数组 - 力扣（LeetCode）\n在山形边界开区间所夹的区间内，满足所有元素大于等于山形边界元素 $x$ ，即 $x = \\min(a[l+1] \\sim a[r-1]) $。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def validSubarraySize(self, nums: List[int], threshold: int) -\u0026gt; int: n = len(nums) # 单调栈解法 stk, left = [], [-1] * n for i in range(n): x = nums[i] while stk and x \u0026lt;= nums[stk[-1]]: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk, right = [], [n] * n for i in range(n - 1, -1, -1): x = nums[i] while stk and x \u0026lt;= nums[stk[-1]]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) for i, x in enumerate(nums): l, r = left[i], right[i] k = r - l - 1 if x \u0026gt; (threshold / k): return k return -1 单调队列 滑窗最大值 ~ 维护递减小队列； 滑窗最小值 ~ 维护递增队列\n239. 滑动窗口最大值 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: n = len(nums) res = [] q = deque() for i, x in enumerate(nums): # 1.入，需要维护单调减队列的有序性 while q and x \u0026gt;= nums[q[-1]]: q.pop() q.append(i) # 2.出，当滑动窗口区间长度大于k的时候，弹出去左端的 if i - q[0] + 1 \u0026gt; k: q.popleft() # 记录元素 if i \u0026gt;= k - 1: res.append(nums[q[0]]) return res 2398. 预算内的最多机器人数目 - 力扣（LeetCode）\n单调队列 + 滑动窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -\u0026gt; int: n = len(chargeTimes) res = 0 s = l = 0 # 滑窗的和 / 窗口左边界 q = deque() # 单调队列维护最大值 # 滑动窗口 for i, x in enumerate(chargeTimes): while q and x \u0026gt;= chargeTimes[q[-1]]: q.pop() q.append(i) s += runningCosts[i] while i - l + 1 \u0026gt; 0 and s * (i - l + 1) + chargeTimes[q[0]] \u0026gt; budget: s -= runningCosts[l] l += 1 if l \u0026gt; q[0]: q.popleft() res = max(res, i - l + 1) return res 单调栈优化dp 2617. 网格图中最少访问的格子数 - 力扣（LeetCode）\n暴力dp转移做法\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def minimumVisitedCells(self, grid: List[List[int]]) -\u0026gt; int: m, n = len(grid), len(grid[0]) f = [[inf] * n for _ in range(m)] f[-1][-1] = 0 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): g = grid[i][j] for k in range(1, min(g + 1, m - i)): f[i][j] = min(f[i][j], f[i + k][j] + 1) for k in range(1, min(g + 1, n - j)): f[i][j] = min(f[i][j], f[i][j + k] + 1) return f[0][0] + 1 if f[0][0] != inf else -1 单调栈 + 二分 优化dp\n倒序枚举$i,~j$ $$ f[i][j]=\\min\\left\\{\\min_{k=j+1}^{j+g}f[i][k], ~\\min_{k=i+1}^{i+g}f[k][j]\\right\\}+1 $$ 可以发现左边界$i$ 是递减的，右边界$ j +g$ 是不确定的。联想到滑动窗口最值问题，维护一个向左增长的栈，栈元素自左向右递减。\n由于栈中元素有序，每次查找只需要二分即可找出最值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def minimumVisitedCells(self, grid: List[List[int]]) -\u0026gt; int: m, n = len(grid), len(grid[0]) stkyy = [deque() for _ in range(n)]\t# 列上单调栈 f = 0\t# 行上单调栈 for i in range(m - 1, -1, -1): stkx = deque() for j in range(n - 1, -1, -1): g, stky = grid[i][j], stkyy[j] f = 1 if i == m - 1 and j == n - 1 else inf if g \u0026gt; 0: if stkx and j + g \u0026gt;= stkx[0][1]: mnj = bisect_left(stkx, j + g + 1, key = lambda x: x[1]) - 1 f = stkx[mnj][0] + 1 if stky and i + g \u0026gt;= stky[0][1]: mni = bisect_left(stky, i + g + 1, key = lambda x: x[1]) - 1 f = min(f, stky[mni][0] + 1) if f \u0026lt; inf: while stkx and f \u0026lt;= stkx[0][0]: stkx.popleft() stkx.appendleft((f, j)) while stky and f \u0026lt;= stky[0][0]: stky.popleft() stky.appendleft((f, i)) return f if f != inf else -1 LCP 32. 批量处理任务 - 力扣（LeetCode）\n二分单调栈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def processTasks(self, tasks: List[List[int]]) -\u0026gt; int: stk = [(-1, -1, 0)] tasks.sort(key = lambda x: x[1]) for l, r, t in tasks: p = bisect_left(stk, (l, )) - 1 blue = stk[-1][2] - stk[p][2] red = max(0, stk[p][1] - l + 1) t -= blue + red if t \u0026lt;= 0: continue nl, nr, nt = r - t + 1, r, stk[-1][2] + t while stk: ll, rr, _ = stk[-1] if nl \u0026gt; rr: break nl = ll - (rr - nl + 1) stk.pop() stk.append((nl, nr, nt)) return stk[-1][2] 单调队列优化dp 2944. 购买水果需要的最少金币数 - 力扣（LeetCode）\n暴力做法：$O(n^2)$\n1 2 3 4 5 6 7 8 9 10 11 12 def minimumCoins(self, prices: List[int]) -\u0026gt; int: n = len(prices) # f[i] 表示获得 i及其以后的所有水果的最少开销 f = [inf] * (n + 1) for i in range(n, 0, -1): # [i + 1, 2 * i] 免费 if 2 * i \u0026gt;= n: f[i] = prices[i - 1] else: for j in range(i + 1, 2 * i + 2): f[i] = min(f[i], f[j] + prices[i - 1]) return f[1] 注意到 i递减，区间 $[i + 1, 2 \\times i + 1]$是一个长度为为i + 1 的滑动窗口，转移成滑动窗口最值问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def minimumCoins(self, prices: List[int]) -\u0026gt; int: n = len(prices) # f[i] 表示获得 i及其以后的所有水果的最少开销 f = [inf] * (n + 1) q = deque() for i in range(n, 0, -1): # i递减，区间[i + 1, 2 * i + 1]是一个定长为i + 1 的滑动窗口 while q and q[-1][1] - (i + 1) + 1 \u0026gt; i + 1: q.pop() if 2 * i \u0026gt;= n: f[i] = prices[i - 1] else: f[i] = q[-1][0] + prices[i - 1] while q and f[i] \u0026lt;= q[0][0]: q.popleft() q.appendleft((f[i], i)) return f[1] 前缀/差分 一维差分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def maximumBeauty(self, nums: List[int], k: int) -\u0026gt; int: n = len(nums) d = k - min(nums) for i in range(n): nums[i] += d mx = max(nums) + k a = [0] * (mx + 1) d = [0] * (mx + 2) for x in nums: d[x - k] += 1 d[x + k + 1] -= 1 a[0] = d[0] for i in range(1, mx + 1): a[i] = a[i - 1] + d[i] return max(a) 二维差分 1 2 3 4 5 6 7 8 9 10 11 d = [[0] * (n + 2) for _ in range(m + 2)] # 对矩阵中执行操作，使得左上角为(i, j)，右下角为(x, y)的矩阵都加k，等价于如下操作 d[i + 1][j + 1] += k d[x + 2][y + 2] += k d[i + 1][y + 2] -= k d[x + 2][j + 1] -= k # 还原差分时，直接原地还原 for i in range(m): for j in rang(n): d[i + 1][j + 1] += d[i][j + 1] + d[i + 1][j] - d[i][j] 二维前缀 3070. 元素和小于等于 k 的子矩阵的数目 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class PreSum2d: # 二维前缀和(支持加法和异或)，只能离线使用，用n*m时间预处理，用O1查询子矩阵的和；op=0是加法，op=1是异或 def __init__(self,g,op=0): m,n = len(g),len(g[0]) self.op = op self.p=p=[[0]*(n+1) for _ in range(m+1)] if op == 0: for i in range(m): for j in range(n): p[i+1][j+1] = p[i][j+1]+p[i+1][j]-p[i][j]+g[i][j] elif op==1: for i in range(m): for j in range(n): p[i+1][j+1] = p[i][j+1]^p[i+1][j]^p[i][j]^g[i][j] # O(1)时间查询闭区间左上(a,b),右下(c,d)矩形部分的数字和。 def sum_square(self,a,b,c,d): if self.op == 0: return self.p[c+1][d+1]+self.p[a][b]-self.p[a][d+1]-self.p[c+1][b] elif self.op==1: return self.p[c+1][d+1]^self.p[a][b]^self.p[a][d+1]^self.p[c+1][b] class NumMatrix: def __init__(self, mat: List[List[int]]): self.pre = PreSum2d(mat) def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -\u0026gt; int: # pre = self.pre return self.pre.sum_square(row1,col1,row2,col2) class Solution: def countSubmatrices(self, grid: List[List[int]], k: int) -\u0026gt; int: n = len(grid) m = len(grid[0]) res = 0 p = NumMatrix(grid) for i in range(n): for j in range(m): if p.sumRegion(0, 0, i, j) \u0026lt;= k: res += 1 return res pre[i + 1][j + 1] 是左上角为(0, 0) 右下角为 (i, j)的矩阵的元素和。\n如果是前缀异或是：\np[i+1][j+1] = p[i][j+1]^p[i+1][j]^p[i][j]^g[i][j]\n1 2 3 4 5 6 7 8 9 10 11 12 def countSubmatrices(self, grid: List[List[int]], k: int) -\u0026gt; int: m, n = len(grid), len(grid[0]) pre = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): pre[i + 1][j + 1] = pre[i][j + 1] + pre[i + 1][j] - pre[i][j] + grid[i][j] res = 0 for i in range(m): for j in range(n): if pre[i + 1][j + 1] \u0026lt;= k: res += 1 return res 前缀异或 / 自定义前缀操作\n1 pre = list(accumulate(nums, xor, initial = 0)) 数学 数论 取整函数 上下取整转换 $$ \\left\\lceil \\frac{n}{m} \\right\\rceil = \\left\\lfloor \\frac{n - 1}{m} \\right\\rfloor + 1 = \\left\\lfloor \\frac{n + m -1}{m} \\right\\rfloor $$证明：由于有 $\\left\\lceil \\frac{n}{m} \\right\\rceil = \\left\\lfloor \\frac{n}{m} \\right\\rfloor$ 当且仅当 $n=k \\cdot m$ 时成立，当 $n=k\\cdot m-r,r\\in(0,m)$，一定有 $k=\\left\\lceil \\frac{k\\cdot m}{m} \\right\\rceil =\\left\\lceil \\frac{k\\cdot m-r}{m} \\right\\rceil = \\left\\lceil \\frac{k\\cdot m-r+1}{m} \\right\\rceil = 1+ \\left\\lfloor \\frac{k\\cdot m-r}{m} \\right\\rfloor$，显然 $k\\cdot m-r+1 \\in R$，令其等于$n$ 时得证 $\\left\\lceil \\frac{n}{m} \\right\\rceil =1+ \\left\\lfloor \\frac{n-1}{m} \\right\\rfloor$。 $$ \\left\\lfloor \\frac{n}{m} \\right\\rfloor =\\left\\lceil \\frac{n+1}{m} \\right\\rceil-1 $$灵神恒等式*\n$\\left\\lfloor\\frac{\\lfloor n/p\\rfloor}q\\right\\rfloor=\\left\\lfloor\\frac n{pq}\\right\\rfloor $\n1553. 吃掉 N 个橘子的最少天数 - 力扣（LeetCode）\n实际上这个结论可以推广到任意个数，比如：$\\left\\lfloor\\frac{\\left\\lfloor\\frac{\\left\\lfloor\\frac n{p_1}\\right\\rfloor}{p_2}\\right\\rfloor}{p_3}\\right\\rfloor=\\left\\lfloor\\frac n{p_1\\cdot p_2\\cdot p_3}\\right\\rfloor $。\n题目详情 - 数字游戏 - HydroOJ\n不等式 $$ x-1\u003c\\lfloor x\\rfloor\\leqslant x\\leqslant\\lceil x\\rceil","date":"2025-07-16T00:00:00Z","permalink":"https://keepulser.top/p/%E7%AE%97%E6%B3%95/","title":"Python算法竞赛模板"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://keepulser.top/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://keepulser.top/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://keepulser.top/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://keepulser.top/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://keepulser.top/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://keepulser.top/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://keepulser.top/p/emoji-support/","title":"Emoji Support"}]